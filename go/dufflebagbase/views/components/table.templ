package components

import "fmt"

type TableColumn struct {
	Key      string
	Label    string
	Width    string
	Sortable bool
	Type     string // "text", "email", "badge", "id", "avatar", "actions", "checkbox"
}

type TableRow map[string]interface{}

type TableData struct {
	Columns    []TableColumn
	Rows       []TableRow
	Empty      string
	Selectable bool
}

templ Table(data TableData) {
	<div class="table-wrapper">
		<table class="data-table">
			<thead>
				<tr>
					if data.Selectable {
						<th class="cell-checkbox">
							<input type="checkbox" id="select-all" onchange="toggleSelectAll(this)"/>
						</th>
					}
					for _, col := range data.Columns {
						<th 
							if col.Width != "" {
								style={ "width: " + col.Width }
							}
							if col.Sortable {
								class="sortable"
							}
						>
							{ col.Label }
							if col.Sortable {
								<span class="sort-icon">â†•</span>
							}
						</th>
					}
				</tr>
			</thead>
			<tbody>
				if len(data.Rows) == 0 {
					<tr>
						<td colspan={ fmt.Sprint(len(data.Columns)) } class="empty-state">
							<div class="empty-state-content">
								<svg class="empty-state-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
									<path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
								</svg>
								<div class="empty-state-title">No data found</div>
								<div class="empty-state-text">{ data.Empty }</div>
							</div>
						</td>
					</tr>
				} else {
					for _, row := range data.Rows {
						<tr>
							if data.Selectable {
								<td class="cell-checkbox">
									<input type="checkbox" name="selected[]" value={ fmt.Sprint(row["id"]) }/>
								</td>
							}
							for _, col := range data.Columns {
								@renderCell(col, row[col.Key])
							}
						</tr>
					}
				}
			</tbody>
		</table>
		if len(data.Rows) > 0 {
			<div class="table-footer">
				<div class="table-info">
					Total found: { fmt.Sprint(len(data.Rows)) }
				</div>
			</div>
		}
	</div>
}

templ renderCell(col TableColumn, value interface{}) {
	<td class={ getCellClass(col.Type) }>
		switch col.Type {
		case "id":
			<div class="cell-id">
				<span>{ fmt.Sprint(value) }</span>
				<button class="copy-btn" title="Copy ID">ðŸ“‹</button>
			</div>
		case "email":
			<span class="cell-email">{ fmt.Sprint(value) }</span>
		case "badge":
			if fmt.Sprint(value) == "true" || fmt.Sprint(value) == "True" || fmt.Sprint(value) == "Yes" {
				<span class="cell-badge badge-true">True</span>
			} else if fmt.Sprint(value) == "false" || fmt.Sprint(value) == "False" || fmt.Sprint(value) == "No" {
				<span class="cell-badge badge-false">False</span>
			} else {
				<span class="cell-badge">{ fmt.Sprint(value) }</span>
			}
		case "avatar":
			if value != nil && fmt.Sprint(value) != "" && fmt.Sprint(value) != "N/A" {
				<img src={ fmt.Sprint(value) } alt="Avatar" class="cell-avatar"/>
			} else {
				<div class="cell-avatar-placeholder">-</div>
			}
		case "actions":
			switch v := value.(type) {
			case templ.Component:
				@v
			default:
				@templ.Raw(fmt.Sprint(v))
			}
		default:
			switch v := value.(type) {
			case templ.Component:
				@v
			case string:
				if v == "" || v == "N/A" {
					<span class="text-muted">-</span>
				} else {
					{ v }
				}
			default:
				if fmt.Sprint(v) == "" {
					<span class="text-muted">-</span>
				} else {
					{ fmt.Sprint(v) }
				}
			}
		}
	</td>
	<script>
	// Add click handler for copy buttons after render
	document.addEventListener('DOMContentLoaded', function() {
		document.querySelectorAll('.copy-btn').forEach(function(btn) {
			btn.addEventListener('click', function() {
				var text = this.previousElementSibling.textContent;
				copyToClipboard(text);
			});
		});
		
		document.querySelectorAll('.sortable').forEach(function(th) {
			th.addEventListener('click', function() {
				var columnKey = this.textContent.replace('â†•', '').trim();
				sortTable(columnKey);
			});
		});
	});
	</script>
}

func getCellClass(cellType string) string {
	switch cellType {
	case "checkbox":
		return "cell-checkbox"
	case "actions":
		return "cell-actions"
	default:
		return ""
	}
}

// Pagination component
type PaginationData struct {
	CurrentPage int
	TotalPages  int
	PageSize    int
	TotalItems  int
}

templ Pagination(data PaginationData, baseURL string) {
	<div class="table-footer">
		<div class="table-info">
			Showing { fmt.Sprintf("%d", (data.CurrentPage-1)*data.PageSize + 1) } - 
			{ fmt.Sprintf("%d", min(data.CurrentPage*data.PageSize, data.TotalItems)) } of { fmt.Sprintf("%d", data.TotalItems) }
		</div>
		<div class="pagination">
			@templ.Raw(fmt.Sprintf(`
				<button class="pagination-btn" onclick="goToPage('%s', %d)" %s>Previous</button>
			`, baseURL, data.CurrentPage-1, disabledAttr(data.CurrentPage <= 1)))
			
			// Show page numbers with ellipsis for large page counts
			if data.TotalPages <= 7 {
				for i := 1; i <= data.TotalPages; i++ {
					@templ.Raw(fmt.Sprintf(`
						<button class="pagination-btn%s" onclick="goToPage('%s', %d)">%d</button>
					`, isActive(i, data.CurrentPage), baseURL, i, i))
				}
			} else {
				// Always show first page
				@templ.Raw(fmt.Sprintf(`
					<button class="pagination-btn%s" onclick="goToPage('%s', 1)">1</button>
				`, isActive(1, data.CurrentPage), baseURL))
				
				if data.CurrentPage > 3 {
					<span class="pagination-ellipsis">...</span>
				}
				
				// Show pages around current
				for i := max(2, data.CurrentPage-1); i <= min(data.TotalPages-1, data.CurrentPage+1); i++ {
					@templ.Raw(fmt.Sprintf(`
						<button class="pagination-btn%s" onclick="goToPage('%s', %d)">%d</button>
					`, isActive(i, data.CurrentPage), baseURL, i, i))
				}
				
				if data.CurrentPage < data.TotalPages - 2 {
					<span class="pagination-ellipsis">...</span>
				}
				
				// Always show last page
				@templ.Raw(fmt.Sprintf(`
					<button class="pagination-btn%s" onclick="goToPage('%s', %d)">%d</button>
				`, isActive(data.TotalPages, data.CurrentPage), baseURL, data.TotalPages, data.TotalPages))
			}
			
			@templ.Raw(fmt.Sprintf(`
				<button class="pagination-btn" onclick="goToPage('%s', %d)" %s>Next</button>
			`, baseURL, data.CurrentPage+1, disabledAttr(data.CurrentPage >= data.TotalPages)))
		</div>
	</div>
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func isActive(page, currentPage int) string {
	if page == currentPage {
		return " active"
	}
	return ""
}

func disabledAttr(disabled bool) string {
	if disabled {
		return "disabled"
	}
	return ""
}